/*
   Package for generating datasets for cross-validation
   purposes.


   written by: Artur Tarassow (atecon@posteo.de)

*/


function bundle default_cv_opts ()

    # Set default values
    bundle self = null
    string self.cv_type = "kfold"	# "kfold", "rep_kfold", "loo", etc...

    scalar self.n_folds = 5			# divide sample into k groups of samples


    return self
end function


function void check_bundle (bundle *self)
    /* Some initial checks for bundle completeness */
        
    if !inbundle(self, "y")
        funcerr "Provide a series or vector of the endogenous named 'y'."
    endif
    if !inbundle(self, "X")
        funcerr "Provide a series/list or matrix of the exogenous named 'X'."
    endif

    if typeof(self.y)==3 && typeof(self.X)==3 # both a matrices
        if !inbundle(self, "index")
            funcerr "Provide a vector holding index observations values (via 'genr index') named 'index'."
        elif inbundle(self, "index")
            if typeof(self.Ã­ndex)!=3
                funcerr "Make sure your object 'index' is of type matrix (row vector)."
            endif            
        endif
    endif
end function


function bundle CrossValidation (bundle b)
                                 /*                                   
                                 series y "Dep. variable",
                                 const list X "Regressors",
                                   bundle opts[null])
                                  */

    # https://scikit-learn.org/stable/modules/cross_validation.html

    /*=======================*/
    /* Main package function */
    /*=======================*/

    # Set up the bundle
    bundle self = default_cv_opts()
    if exists(b)
        # override defaults
        self = b + self
    endif
    print self    


    # Initial checks
    #===============
#    check_bundle(&self)


    # Drop missings
    # TODO: think about how to handle NAs
    #    smpl --no-missing y X
   
    if !inbundle(self, "index")
        genr index
        self.index = index		# index series for checking that values are related to the right unit
    endif        

    # Call evaluation method
    if self.cv_type=="kfold"
        kfold(&self)
    endif

    return self
end function


function bundle kfold (bundle *self)

/* Function for running k-fold:

   Splits data in train/test sets.
   Split dataset into k consecutive folds (without shuffling by default).
   Each fold can be used once as a validation while the k - 1 remaining
   folds form the training set.
   
   See: https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html
    */

    y = self.y
    X = self.X
    index = self.index

    # Arrays holding samples
    matrices self.y_train = array(self.n_folds)
    matrices self.y_test = array(self.n_folds)
    matrices self.X_train = array(self.n_folds)
    matrices self.X_test = array(self.n_folds)

    # Lenght of each test sample
    scalar T = (typeof(y)==2) ? nobs(y) : rows(y)
    scalar self.foldsize = int( T/self.n_folds )
    scalar rest = T - self.foldsize		# no. of remainder obs

    # initial test set
    scalar start = min(index)
    scalar ende = (start+self.foldsize)-1

    # Start looping
    loop i=1..self.n_folds -q
                

        # Test set
        if typeof(y)==2			# For series-based approach
            series active_set = 0					# don't drop: indicator for current sample
            smpl index>=start && index<=ende --restrict
            smpl y X --no-missing
            active_set = 1						# don't drop
            #       print y index active_set -o
            self.y_test[i] = {index} ~ {y}
            self.X_test[i] = {index} ~ {X}
            
        else					# For matrix-based approach
            matrix active_set = (index.>=start && index.<=ende)
            
            self.y_test[i] = selifr(index,active_set) ~ selifr(y,active_set) #index[start:ende] ~ y[start:ende,]
            self.X_test[i] = selifr(index,active_set) ~ selifr(X,active_set)
        endif


        # Training set
        if typeof(y)==2			# For series-based approach
            smpl active_set==0 --restrict --replace
            smpl y X --no-missing
            #        print y index active_set -o
            self.y_train[i] = {index} ~ {y}
            self.X_train[i] = {index} ~ {X}
            smpl full
            
        else
            active_set = (active_set.=1) ? 0 : 1				# select training set
            self.y_train[i] = selifr(index,active_set) ~ selifr(y,active_set)
            self.X_train[i] = selifr(index,active_set) ~ selifr(X,active_set)
        endif                
        

        # update start/ ende
        start += self.foldsize
        ende = start + self.foldsize-1
        ende = (i==self.n_folds) ? (ende+rest) : ende
    endloop

    return self
end function

