set verbose off
clear 

#include ridge.gfn --force

string wd = "/home/at/git/ridge"

include "@wd/ridge.inp"		# SET PATH

scalar runEX = 4		# select an example

# Select an example
if runEX==1
    open australia.gdt -q --preserve
    
    # define the variables
    series LHS = ldiff(PAU)
    list RHS = const LHS(-1 to -2) IUS(-1 to -2)  IAU(-1 to -2)    
    
    ols LHS RHS					# benchmark
    
elif runEX==2
    # Dataset from glmnet
    open "@wd/glmnet_QSE.csv" --quiet  --preserve
    setobs 1 1 --special-time-series
    setobs 1 1 --cross-section

    rename X1 LHS
    list RHS = const dataset
    RHS -= LHS
    
elif runEX==3
    # SIMULATION
    nulldata 500
    set seed 1234
    setobs 1 1 --time-series
    series e = normal()
    e[1] = NA
    e[2] = NA
    series LHS = 1
    series LHS = 4.3 + 0.8*LHS(-1) - 0.4*LHS(-2) + 0.2*LHS(-6) + e
    matrix X = mnormal($nobs, 50)		# further exogenous
    list RHS = const LHS(-1 to -6)		# arbtrary lags of the endogenous
    loop i=1..cols(X) -q
        series S$i = X[,i]
        RHS += S$i
    endloop

elif runEX==4
    open mroz.gdt -q --preserve    
    series LHS = hwage
    list RHS = const dataset    
    ols LHS RHS
    
    smpl --contiguous LHS RHS
endif


# run the main function with default values
#===========================================
bundle opts = null

# lambda values to evaluate (optional; default 100 values between [0.1,400])
# Loss function for CV (optional, default "rmse")
scalar opts.l_min = 0.001
scalar opts.l_max = 200
#scalar opts.nlambda = 150				# number of lambda values (default: 100)
#string opts.loss_type = "mape"			# 'me', 'rmse' (default), 'mae', 'mape'
string opts.cv_type = "rolwin"			# 'kfold' (default), 'loo', 'rolwin', 'recwin'
scalar opts.win_size = int(0.5*$nobs)	# length of window, only for 'rolwin' and 'recwin' types

# Run training and evaluation using cross-validation
#====================================================
bundle b_ridge = ridge(LHS, RHS, opts)

# Plot loss as a function of lambda
plotLoss(&b_ridge)

# Plot solution path
plotBeta(&b_ridge)

# Grab coeff. conditional on optimal lambda
#==========================================
eval b_ridge.beta_min


# Estimate beta for a given lambda value
#========================================
smpl --contiguous LHS RHS
bhat = ridgeAux(b_ridge.lambda_min, {LHS}, {RHS})
bhat

